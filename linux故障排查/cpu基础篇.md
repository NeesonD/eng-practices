[TOC]

### 基础篇一：平均负载

平均负载指的是，**单位时间**内的平均**活跃进程数**（可运行状态和不可中断状态），和 CPU 没有直接关系

可运行状态进程：R，正在使用或者正在等待 CPU 的进程
不可中断状态进程：正处于内核态关健流程中的进程，且不可打断。最常见的就是**等待硬件 IO 响应**

**该指标为多少时是合理的**

* 确认系统 CPU 个数
```shell script
grep 'model name' /proc/cpuinfo | wc -l
```
* 查看平均负载
```shell script
uptime
                                                    1min  5min  15min
18:24:16 up 41 days,  6:38, 1 users,  load average: 1.70, 1.58, 1.60
```
通过分析三个负载值，可以看出系统负载是平稳的，还是降低或者升高的

* 当平均负载高于 CPU 数量 70% 的时候，就需要分析负载高的问题了；或者当系统 CPU 出现突刺的时候
    * CPU 密集型进程，使用大量 CPU 会导致平均负载升高；
    * **IO 密集型进程，等待 IO 也会导致平均负载升高**，但是 CPU 使用率不一定高
    * 大量等待 CPU 的进程调度也会导致平均负载高，此时 CPU 的使用率也会比较高
 
#### 实操演示
* stress: 压测工具
* sysstat：性能监控工具

```shell script
yum install stress sysstat
```

##### 模拟 CPU 密集型应用

```shell script
## 压力测试
stress --cpu 1 --timeout 600

## 负载变化
watch -d uptime

## 查看 cpu 使用率的变化
mpstat -P ALL 5

## 查看是哪个进程导致了 CPU 升高
pidstat -u 5 1
```

##### 模拟 IO 密集型应用

```shell script
## 压力测试 不停的 sync
stress -i 1 --timeout 600

## 负载变化
watch -d uptime

## 查看 cpu 使用率的变化
mpstat -P ALL 5

## 查看是哪个进程导致了 CPU 升高
pidstat -u 5 1

```

##### 模拟大量进程场景

```shell script
## 压力测试 模拟8个进程

stress -c 8 --timeout 600

## 负载变化
watch -d uptime

## 查看 cpu 使用率的变化
mpstat -P ALL 5 5

## 查看是哪个进程导致了 CPU 升高
pidstat -u 5 1

```

### 基础篇二：CPU 上下文切换

#### 进程上下文切换

![](pic/linux-03.png)

* 一次**系统调用**的过程，其实是**发生了两次 CPU 上下文切换**
    * CPU 寄存器里原来用户态的指令位置，需要先保存起来.为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置，然后跳到内核态运行内核任务
    * 系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程
    * 这里没有发生进程上下文切换，只发生了 CPU 上下文切换
* **进程的上下文切换**就比**系统调用**时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈
* 何时会进行上下文切换
    * 时间片轮转
    * 进程在资源不足的情况下，会挂起
    * 进程主动挂起
    * 优先级高的进程抢占
    * 硬件中断

#### 线程上下文切换

* 线程是调度的基本单位，而进程则是资源拥有的基本单位
* 同进程中的线程切换，只需要切换线程的私有数据、寄存器等不共享的数据
* 不同进程中的线程切换，等同于进程切换

#### 中断上下文切换

* 中断处理会打断进程的正常调度和执行
* 对同一个 CPU 来说，中断处理比进程拥有更高的优先级

-------------

#### 小结

* CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，**一般情况下不需要我们特别关注**
* 但过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降

#### 如何查看系统上下文切换

```
vmstat 5
        -----------memory---------- ---swap-- -----io---- -system-- ------cpu---
r  b   swpd   free   buff  cache     si   so    bi   bo   in   cs  us sy id wa st
5  0      0 380788 124048 5310792    0    0     6    26    3    4  5  2  93  0  0

* cs（context switch）是每秒上下文切换的次数
* in（interrupt）则是每秒中断的次数
* r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数（应该不能超过 CPU 数量）
* b（Blocked）则是处于不可中断睡眠状态的进程数

pidstat -w 5  //查看每个进程的上下文切换数

10:03:34 PM   UID       PID   cswch/s nvcswch/s  Command
10:03:39 PM     0         1      0.20      0.00  systemd
10:03:39 PM     0         3      3.98      0.00  ksoftirqd/0
10:03:39 PM     0         7      2.39      0.00  migration/0
10:03:39 PM     0         9    176.29      0.00  rcu_sched
10:03:39 PM     0        10      0.40      0.00  watchdog/0

* cswch, 表示每秒自愿上下文切换的次数
    * 所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换
* nvcswch, 每秒非自愿上下文切换的次数
    * 而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换

```

#### 实操演示

* sysbench：多线程基准测试工具
* sysstat

```
yum install  sysbench

# 间隔1秒后输出1组数据
vmstat 1 1


# 以10个线程运行5分钟的基准测试，模拟多线程切换的问题
sysbench --threads=10 --max-time=300 threads run

procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
13  0      0 323360 119296 5319940    0    0     0  1232 5681 1505336 46 54  0  0  0
24  0      0 248820 119308 5319908    0    0     0   436 4043 1404945 61 39  0  0  0
 9  0      0 253744 119308 5320028    0    0     0     4 4120 1446869 59 42  0  0  0
17  0      0 236256 119308 5319860    0    0     8   192 4694 1484881 52 48  0  0  0

* r 很大，说明很多进程在等待
* cs 很大，说明有很多上下文切换
* cpu 使用率很高

# 每隔1秒输出1组数据（需要 Ctrl+C 才结束）
# -w参数表示输出进程切换指标，而-u参数则表示输出CPU使用指标
pidstat -w -u 1

# 每隔1秒输出一组数据（需要 Ctrl+C 才结束）
# -wt 参数表示输出线程的上下文切换指标
pidstat -wt 1


# -d 参数表示高亮显示变化的区域，观察中断的变化情况
watch -d cat /proc/interrupts

```

* 每秒的上下文切换应该在一万以内（取决于 CPU）
* 根据上下文切换的类型，再做具体分析
    * **自愿上下文切换**变多了，说明**进程都在等待资源**，有可能发生了 I/O 等其他问题
    * **非自愿上下文切换**变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 **CPU 的确成了瓶颈**
    * **中断次数**变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型

#### 线上 CPU 占用率高，如何排查

**CPU 使用率**

CPU 重要指标

* user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。
* nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。
* system（通常缩写为 sys），代表内核态 CPU 时间。idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。
* iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。
* irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。
* softirq（通常缩写为 si），代表处理软中断的 CPU 时间。steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。
* guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。
* guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。

------------


通过性能分析工具，查看 CPU 的使用率，关键点在于设置好间隔时间

Q: 如何查看 CPU 使用率高的进程

使用 top 或者 pidstat，通过这两个工具就能够发现 CPU 使用率高的进程

Q: 哪种工具适合在第一时间分析进程的 CPU 问题呢

使用 perf top

```
Samples: 124K of event 'cpu-clock', 4000 Hz, Event count (approx.): 6921386876 lost: 0/0 drop: 0/0
Overhead  Shared   Object                          Symbol
  12.04%  [kernel]                                 [k] _raw_spin_unlock_irqrestore
   7.22%  [kernel]                                 [k] slab_unmergeable
   4.98%  [kernel]                                 [k] finish_task_switch
   3.15%  [kernel]                                 [k] run_timer_softirq

* Samples: 采样数
* Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示
* Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等
* Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间
* Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示
```

使用 perf record(采集) 和 perf report(解析)


```
## **先用 top 找到 CPU 使用率高的进程**

# -g开启调用关系分析，-p指定进程号21515

perf top -g -p 21515

# **容器**

perf record -g -p 21515，执行一会儿（比如15秒）按ctrl+c停止

把生成的 perf.data 拷贝到容器里面
```

--------

#### 小结

流程：通过 top 或者 pidstat 找到进程 -> 再通过 perf record -g -p 21515 分析进程中占 CPU 的执行函数

* 用户 CPU 和 Nice CPU 高，说明用户态进程占用了较多的 CPU，所以应该着重排查进程的性能问题
* 系统 CPU 高，说明内核态占用了较多的 CPU，所以应该着重排查内核线程或者系统调用的性能问题
* I/O 等待 CPU 高，说明等待 I/O 的时间比较长，所以应该着重排查系统存储是不是出现了 I/O 问题
* 软中断和硬中断高，说明软中断或硬中断的处理程序占用了较多的 CPU，所以应该着重排查内核中的中断服务程序

**关键点：一是搞清楚排查流程，二是搞清楚各种 CPU 指标的含义以及偏高的原因**

